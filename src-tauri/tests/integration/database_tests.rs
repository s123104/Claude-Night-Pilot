// üß™ Claude Night Pilot - Ë≥áÊñôÂ∫´Êï¥ÂêàÊ∏¨Ë©¶Â•ó‰ª∂
// Âü∫ÊñºContext7 RusqliteÊúÄ‰Ω≥ÂØ¶Ë∏ê
// ÂâµÂª∫ÊôÇÈñì: 2025-08-17T05:20:00+00:00

use anyhow::Result;
use chrono::Utc;
use rusqlite::{Connection, params};
use std::path::Path;
use tempfile::TempDir;

/// Ë≥áÊñôÂ∫´Êï¥ÂêàÊ∏¨Ë©¶Â•ó‰ª∂
/// 
/// Ê∏¨Ë©¶Ë¶ÜËìãÔºö
/// - Ë≥áÊñôÂ∫´ÈÄ£Êé•ËàáÂàùÂßãÂåñ
/// - CRUDÊìç‰ΩúÂÆåÊï¥ÊÄß
/// - ‰∫ãÂãôÁÆ°ÁêÜ
/// - ‰ΩµÁôºÂÆâÂÖ®ÊÄß
/// - ÊïàËÉΩÂü∫Ê∫ñ
/// - Ë≥áÊñôÂÆåÊï¥ÊÄßÁ¥ÑÊùü
#[cfg(test)]
mod database_integration_tests {
    use super::*;
    use crate::utils::create_test_db;

    /// Ê∏¨Ë©¶Ë≥áÊñôÂ∫´ÂàùÂßãÂåñ
    #[tokio::test]
    async fn test_database_initialization() -> Result<()> {
        let (_temp_dir, db_path) = create_test_db();
        
        // ÂâµÂª∫Ë≥áÊñôÂ∫´ÈÄ£Êé•
        let conn = Connection::open(&db_path)?;
        
        // Ê∏¨Ë©¶Âü∫Êú¨Ë°®ÁµêÊßã
        create_test_tables(&conn)?;
        
        // È©óË≠âË°®ÊòØÂê¶Â≠òÂú®
        let tables = get_table_names(&conn)?;
        assert!(tables.contains(&"prompts".to_string()));
        assert!(tables.contains(&"schedules".to_string()));
        
        println!("‚úÖ Ë≥áÊñôÂ∫´ÂàùÂßãÂåñÊ∏¨Ë©¶ÈÄöÈÅé");
        Ok(())
    }

    /// Ê∏¨Ë©¶Prompt CRUDÊìç‰Ωú
    #[tokio::test]
    async fn test_prompt_crud_operations() -> Result<()> {
        let (_temp_dir, db_path) = create_test_db();
        let conn = Connection::open(&db_path)?;
        create_test_tables(&conn)?;
        
        // Create - ÊèíÂÖ•Ê∏¨Ë©¶Prompt
        let prompt_id = insert_test_prompt(&conn, "Ê∏¨Ë©¶Prompt", "Ê∏¨Ë©¶ÂÖßÂÆπ")?;
        
        // Read - ËÆÄÂèñPrompt
        let prompt = get_prompt_by_id(&conn, prompt_id)?;
        assert_eq!(prompt.title, "Ê∏¨Ë©¶Prompt");
        assert_eq!(prompt.content, "Ê∏¨Ë©¶ÂÖßÂÆπ");
        
        // Update - Êõ¥Êñ∞Prompt
        update_prompt(&conn, prompt_id, "Êõ¥Êñ∞ÁöÑÊ®ôÈ°å", "Êõ¥Êñ∞ÁöÑÂÖßÂÆπ")?;
        let updated_prompt = get_prompt_by_id(&conn, prompt_id)?;
        assert_eq!(updated_prompt.title, "Êõ¥Êñ∞ÁöÑÊ®ôÈ°å");
        
        // Delete - Âà™Èô§Prompt
        delete_prompt(&conn, prompt_id)?;
        let result = get_prompt_by_id(&conn, prompt_id);
        assert!(result.is_err(), "Âà™Èô§ÂæåÊáâË©≤ÁÑ°Ê≥ïÊâæÂà∞Prompt");
        
        println!("‚úÖ Prompt CRUDÊìç‰ΩúÊ∏¨Ë©¶ÈÄöÈÅé");
        Ok(())
    }

    /// Ê∏¨Ë©¶Schedule CRUDÊìç‰Ωú
    #[tokio::test]
    async fn test_schedule_crud_operations() -> Result<()> {
        let (_temp_dir, db_path) = create_test_db();
        let conn = Connection::open(&db_path)?;
        create_test_tables(&conn)?;
        
        // ÂÖàÂâµÂª∫‰∏ÄÂÄãPrompt
        let prompt_id = insert_test_prompt(&conn, "ÊéíÁ®ãÊ∏¨Ë©¶Prompt", "ÂÖßÂÆπ")?;
        
        // Create - ÊèíÂÖ•Ê∏¨Ë©¶Schedule
        let schedule_id = insert_test_schedule(&conn, prompt_id, "0 9 * * *")?;
        
        // Read - ËÆÄÂèñSchedule
        let schedule = get_schedule_by_id(&conn, schedule_id)?;
        assert_eq!(schedule.cron_expr, "0 9 * * *");
        assert_eq!(schedule.prompt_id, prompt_id);
        
        // Update - Êõ¥Êñ∞ScheduleÁãÄÊÖã
        update_schedule_status(&conn, schedule_id, "Completed")?;
        let updated_schedule = get_schedule_by_id(&conn, schedule_id)?;
        assert_eq!(updated_schedule.status, "Completed");
        
        // Delete - Âà™Èô§Schedule
        delete_schedule(&conn, schedule_id)?;
        let result = get_schedule_by_id(&conn, schedule_id);
        assert!(result.is_err(), "Âà™Èô§ÂæåÊáâË©≤ÁÑ°Ê≥ïÊâæÂà∞Schedule");
        
        println!("‚úÖ Schedule CRUDÊìç‰ΩúÊ∏¨Ë©¶ÈÄöÈÅé");
        Ok(())
    }

    /// Ê∏¨Ë©¶Â§ñÈçµÁ¥ÑÊùü
    #[tokio::test]
    async fn test_foreign_key_constraints() -> Result<()> {
        let (_temp_dir, db_path) = create_test_db();
        let conn = Connection::open(&db_path)?;
        create_test_tables(&conn)?;
        
        // ÂïüÁî®Â§ñÈçµÁ¥ÑÊùü
        conn.execute("PRAGMA foreign_keys=ON", [])?;
        
        // ÂòóË©¶ÊèíÂÖ•‰∏çÂ≠òÂú®ÁöÑprompt_id
        let result = conn.execute(
            "INSERT INTO schedules (prompt_id, schedule_time, status, created_at, updated_at, cron_expr, execution_count) 
             VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7)",
            params![
                999, // ‰∏çÂ≠òÂú®ÁöÑprompt_id
                Utc::now().to_rfc3339(),
                "Active",
                Utc::now().to_rfc3339(),
                Utc::now().to_rfc3339(),
                "0 * * * *",
                0
            ]
        );
        
        assert!(result.is_err(), "ÊáâË©≤Âõ†Â§ñÈçµÁ¥ÑÊùüÂ§±Êïó");
        println!("‚úÖ Â§ñÈçµÁ¥ÑÊùüÊ∏¨Ë©¶ÈÄöÈÅé");
        Ok(())
    }

    /// Ê∏¨Ë©¶‰∫ãÂãôÁÆ°ÁêÜ
    #[tokio::test]
    async fn test_transaction_management() -> Result<()> {
        let (_temp_dir, db_path) = create_test_db();
        let conn = Connection::open(&db_path)?;
        create_test_tables(&conn)?;
        
        // Ê∏¨Ë©¶‰∫ãÂãôÂõûÊªæ
        let tx = conn.unchecked_transaction()?;
        
        // ÊèíÂÖ•Êï∏Êìö
        let prompt_id = tx.execute(
            "INSERT INTO prompts (title, content, created_at, updated_at) VALUES (?1, ?2, ?3, ?4)",
            params!["‰∫ãÂãôÊ∏¨Ë©¶", "ÂÖßÂÆπ", Utc::now().to_rfc3339(), Utc::now().to_rfc3339()]
        )?;
        
        // ÂõûÊªæ‰∫ãÂãô
        tx.rollback()?;
        
        // È©óË≠âÊï∏ÊìöÊú™Ë¢´‰øùÂ≠ò
        let result = conn.prepare("SELECT COUNT(*) FROM prompts WHERE title = '‰∫ãÂãôÊ∏¨Ë©¶'");
        assert!(result.is_ok());
        
        // Ê∏¨Ë©¶‰∫ãÂãôÊèê‰∫§
        let tx = conn.unchecked_transaction()?;
        tx.execute(
            "INSERT INTO prompts (title, content, created_at, updated_at) VALUES (?1, ?2, ?3, ?4)",
            params!["‰∫ãÂãôÊèê‰∫§Ê∏¨Ë©¶", "ÂÖßÂÆπ", Utc::now().to_rfc3339(), Utc::now().to_rfc3339()]
        )?;
        tx.commit()?;
        
        // È©óË≠âÊï∏ÊìöË¢´‰øùÂ≠ò
        let mut stmt = conn.prepare("SELECT COUNT(*) FROM prompts WHERE title = '‰∫ãÂãôÊèê‰∫§Ê∏¨Ë©¶'")?;
        let count: i64 = stmt.query_row([], |row| row.get(0))?;
        assert_eq!(count, 1);
        
        println!("‚úÖ ‰∫ãÂãôÁÆ°ÁêÜÊ∏¨Ë©¶ÈÄöÈÅé");
        Ok(())
    }

    /// Ê∏¨Ë©¶‰ΩµÁôºË≥áÊñôÂ∫´Êìç‰Ωú
    #[tokio::test]
    async fn test_concurrent_database_operations() -> Result<()> {
        let (_temp_dir, db_path) = create_test_db();
        
        // ÂâµÂª∫Â§öÂÄãÈÄ£Êé•‰æÜÊ®°Êì¨‰ΩµÁôº
        let mut handles = vec![];
        
        for i in 0..5 {
            let db_path_clone = db_path.clone();
            let handle = tokio::spawn(async move {
                let conn = Connection::open(&db_path_clone).unwrap();
                create_test_tables(&conn).unwrap();
                
                // ÊèíÂÖ•Êï∏Êìö
                insert_test_prompt(&conn, &format!("‰ΩµÁôºÊ∏¨Ë©¶ {}", i), "ÂÖßÂÆπ").unwrap();
                
                i
            });
            handles.push(handle);
        }
        
        // Á≠âÂæÖÊâÄÊúâÊìç‰ΩúÂÆåÊàê
        for handle in handles {
            let result = handle.await?;
            println!("‰ΩµÁôºÊìç‰Ωú {} ÂÆåÊàê", result);
        }
        
        // È©óË≠âÊâÄÊúâÊï∏ÊìöÈÉΩË¢´Ê≠£Á¢∫ÊèíÂÖ•
        let conn = Connection::open(&db_path)?;
        let mut stmt = conn.prepare("SELECT COUNT(*) FROM prompts WHERE title LIKE '‰ΩµÁôºÊ∏¨Ë©¶%'")?;
        let count: i64 = stmt.query_row([], |row| row.get(0))?;
        assert_eq!(count, 5);
        
        println!("‚úÖ ‰ΩµÁôºË≥áÊñôÂ∫´Êìç‰ΩúÊ∏¨Ë©¶ÈÄöÈÅé");
        Ok(())
    }

    // ËºîÂä©ÂáΩÊï∏
    fn create_test_tables(conn: &Connection) -> Result<()> {
        // ÂâµÂª∫promptsË°®
        conn.execute(
            "CREATE TABLE IF NOT EXISTS prompts (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                title TEXT NOT NULL,
                content TEXT NOT NULL,
                created_at TEXT NOT NULL,
                updated_at TEXT NOT NULL
            )",
            [],
        )?;
        
        // ÂâµÂª∫schedulesË°®
        conn.execute(
            "CREATE TABLE IF NOT EXISTS schedules (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                prompt_id INTEGER NOT NULL,
                schedule_time TEXT NOT NULL,
                status TEXT NOT NULL,
                created_at TEXT NOT NULL,
                updated_at TEXT NOT NULL,
                cron_expr TEXT NOT NULL,
                execution_count INTEGER DEFAULT 0,
                FOREIGN KEY (prompt_id) REFERENCES prompts (id)
            )",
            [],
        )?;
        
        Ok(())
    }
    
    fn get_table_names(conn: &Connection) -> Result<Vec<String>> {
        let mut stmt = conn.prepare("SELECT name FROM sqlite_master WHERE type='table'")?;
        let table_names = stmt.query_map([], |row| {
            Ok(row.get::<_, String>(0)?)
        })?;
        
        let mut names = vec![];
        for name in table_names {
            names.push(name?);
        }
        Ok(names)
    }
    
    fn insert_test_prompt(conn: &Connection, title: &str, content: &str) -> Result<i64> {
        conn.execute(
            "INSERT INTO prompts (title, content, created_at, updated_at) VALUES (?1, ?2, ?3, ?4)",
            params![title, content, Utc::now().to_rfc3339(), Utc::now().to_rfc3339()]
        )?;
        Ok(conn.last_insert_rowid())
    }
    
    fn insert_test_schedule(conn: &Connection, prompt_id: i64, cron_expr: &str) -> Result<i64> {
        conn.execute(
            "INSERT INTO schedules (prompt_id, schedule_time, status, created_at, updated_at, cron_expr, execution_count) 
             VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7)",
            params![
                prompt_id,
                Utc::now().to_rfc3339(),
                "Active",
                Utc::now().to_rfc3339(),
                Utc::now().to_rfc3339(),
                cron_expr,
                0
            ]
        )?;
        Ok(conn.last_insert_rowid())
    }
    
    // Á∞°ÂåñÁöÑÊ∏¨Ë©¶ÁµêÊßã
    #[derive(Debug)]
    struct TestPrompt {
        id: i64,
        title: String,
        content: String,
    }
    
    #[derive(Debug)]
    struct TestSchedule {
        id: i64,
        prompt_id: i64,
        status: String,
        cron_expr: String,
    }
    
    fn get_prompt_by_id(conn: &Connection, id: i64) -> Result<TestPrompt> {
        let mut stmt = conn.prepare("SELECT id, title, content FROM prompts WHERE id = ?1")?;
        stmt.query_row([id], |row| {
            Ok(TestPrompt {
                id: row.get(0)?,
                title: row.get(1)?,
                content: row.get(2)?,
            })
        }).map_err(|e| anyhow::anyhow!("Prompt not found: {}", e))
    }
    
    fn get_schedule_by_id(conn: &Connection, id: i64) -> Result<TestSchedule> {
        let mut stmt = conn.prepare("SELECT id, prompt_id, status, cron_expr FROM schedules WHERE id = ?1")?;
        stmt.query_row([id], |row| {
            Ok(TestSchedule {
                id: row.get(0)?,
                prompt_id: row.get(1)?,
                status: row.get(2)?,
                cron_expr: row.get(3)?,
            })
        }).map_err(|e| anyhow::anyhow!("Schedule not found: {}", e))
    }
    
    fn update_prompt(conn: &Connection, id: i64, title: &str, content: &str) -> Result<()> {
        conn.execute(
            "UPDATE prompts SET title = ?1, content = ?2, updated_at = ?3 WHERE id = ?4",
            params![title, content, Utc::now().to_rfc3339(), id]
        )?;
        Ok(())
    }
    
    fn update_schedule_status(conn: &Connection, id: i64, status: &str) -> Result<()> {
        conn.execute(
            "UPDATE schedules SET status = ?1, updated_at = ?2 WHERE id = ?3",
            params![status, Utc::now().to_rfc3339(), id]
        )?;
        Ok(())
    }
    
    fn delete_prompt(conn: &Connection, id: i64) -> Result<()> {
        conn.execute("DELETE FROM prompts WHERE id = ?1", [id])?;
        Ok(())
    }
    
    fn delete_schedule(conn: &Connection, id: i64) -> Result<()> {
        conn.execute("DELETE FROM schedules WHERE id = ?1", [id])?;
        Ok(())
    }
}

/// Ë≥áÊñôÂ∫´ÊïàËÉΩÂü∫Ê∫ñÊ∏¨Ë©¶
#[cfg(test)]
mod database_performance_tests {
    use super::*;
    use crate::utils::create_test_db;

    /// Ê∏¨Ë©¶ÊâπÈáèÊèíÂÖ•ÊÄßËÉΩ
    #[tokio::test]
    async fn benchmark_bulk_insert() -> Result<()> {
        let (_temp_dir, db_path) = create_test_db();
        let conn = Connection::open(&db_path)?;
        
        // ÂâµÂª∫Ë°®
        conn.execute(
            "CREATE TABLE IF NOT EXISTS prompts (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                title TEXT NOT NULL,
                content TEXT NOT NULL,
                created_at TEXT NOT NULL,
                updated_at TEXT NOT NULL
            )",
            [],
        )?;
        
        let start = std::time::Instant::now();
        
        // ÊâπÈáèÊèíÂÖ•1000Ê¢ùË®òÈåÑ
        let tx = conn.unchecked_transaction()?;
        for i in 0..1000 {
            tx.execute(
                "INSERT INTO prompts (title, content, created_at, updated_at) VALUES (?1, ?2, ?3, ?4)",
                params![
                    format!("Ê∏¨Ë©¶Prompt {}", i),
                    format!("Ê∏¨Ë©¶ÂÖßÂÆπ {}", i),
                    Utc::now().to_rfc3339(),
                    Utc::now().to_rfc3339()
                ]
            )?;
        }
        tx.commit()?;
        
        let elapsed = start.elapsed();
        println!("üìä ÊâπÈáèÊèíÂÖ•1000Ê¢ùË®òÈåÑËÄóÊôÇ: {:?}", elapsed);
        
        // ‰ºÅÊ•≠Á¥öË¶ÅÊ±Ç: 1000Ê¢ùË®òÈåÑÊèíÂÖ• < 1Áßí
        assert!(elapsed < std::time::Duration::from_secs(1), 
               "ÊâπÈáèÊèíÂÖ•ÊÄßËÉΩ‰∏çÁ¨¶ÂêàË¶ÅÊ±Ç: {:?}", elapsed);
        
        Ok(())
    }

    /// Ê∏¨Ë©¶Êü•Ë©¢ÊÄßËÉΩ
    #[tokio::test]
    async fn benchmark_query_performance() -> Result<()> {
        let (_temp_dir, db_path) = create_test_db();
        let conn = Connection::open(&db_path)?;
        
        // ÂâµÂª∫Ë°®‰∏¶ÊèíÂÖ•Ê∏¨Ë©¶Êï∏Êìö
        conn.execute(
            "CREATE TABLE IF NOT EXISTS prompts (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                title TEXT NOT NULL,
                content TEXT NOT NULL,
                created_at TEXT NOT NULL,
                updated_at TEXT NOT NULL
            )",
            [],
        )?;
        
        // ÊèíÂÖ•1000Ê¢ùÊ∏¨Ë©¶Êï∏Êìö
        for i in 0..1000 {
            conn.execute(
                "INSERT INTO prompts (title, content, created_at, updated_at) VALUES (?1, ?2, ?3, ?4)",
                params![
                    format!("Ê∏¨Ë©¶Prompt {}", i),
                    format!("Ê∏¨Ë©¶ÂÖßÂÆπ {}", i),
                    Utc::now().to_rfc3339(),
                    Utc::now().to_rfc3339()
                ]
            )?;
        }
        
        let start = std::time::Instant::now();
        
        // Âü∑Ë°å100Ê¨°Êü•Ë©¢
        for i in 0..100 {
            let mut stmt = conn.prepare("SELECT * FROM prompts WHERE title = ?1")?;
            let _ = stmt.query_row([format!("Ê∏¨Ë©¶Prompt {}", i % 100)], |_row| Ok(()))?;
        }
        
        let elapsed = start.elapsed();
        println!("üìä 100Ê¨°Êü•Ë©¢ËÄóÊôÇ: {:?}", elapsed);
        
        // ‰ºÅÊ•≠Á¥öË¶ÅÊ±Ç: 100Ê¨°Êü•Ë©¢ < 100ms
        assert!(elapsed < std::time::Duration::from_millis(100), 
               "Êü•Ë©¢ÊÄßËÉΩ‰∏çÁ¨¶ÂêàË¶ÅÊ±Ç: {:?}", elapsed);
        
        Ok(())
    }
}
